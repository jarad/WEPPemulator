---
title: "Weighted Averages of Slope Profiles"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{weigthed_average_slp}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, setup, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

library(WEPPemulator)
library(WEPPR)
library(dplyr)
```

# Introduction

Here's an example slope profile loaded from the package.

```{r}
fpath_slp <- system.file("extdata", "071000090603_2.slp", package = "WEPPR")
(slp <- WEPPR::read_slp(fpath_slp))
```

```{r}
plot(slp)
```


It give us information about the number of OFEs, slope and distance.

To emulate WEPP, we want to compress the available information in a way that can still retain information, so that means engineering new features.

One idea is to calculate the averages of slope weighted by distance.

This document contains 3 methods to perform this weighted average calculation.

# Slope

## Methodology


$$
\frac{\int w(t) s(t) dt}{\int w(t) dt}
$$


```{r}
library(ggplot2)

max_dist <- max(WEPPR:::calculate_total_distance(slp))
# Define sequence of distances along hillslope
dist_seq <- seq(0, max_dist, length.out = 100)

# Evaluate weight functions for each distance in sequence
w_const <- function(t) 1
w_const_seq <- w_const(dist_seq)
w_linear_seq <- dist_seq / max_dist
# Evaluate exponential weight function
b <- 2
w_exp_seq <- b^dist_seq
# Normalize exponential weight function to range 0 to 1
w_exp_seq_norm <- (w_exp_seq - min(w_exp_seq)) / (max(w_exp_seq) - min(w_exp_seq))

# Create data frame for plotting
plot_df <- data.frame(distance = dist_seq,
                      constant = w_const_seq,
                      linear = w_linear_seq,
                      exponential = w_exp_seq_norm)

# Plot weight functions
ggplot(plot_df, aes(x = distance)) +
  geom_line(aes(y = constant), color = "blue") +
  geom_line(aes(y = linear), color = "green") +
  geom_line(aes(y = exponential), color = "red") +
  labs(x = "Distance along hillslope", y = "Weight") +
  theme_bw()
```


$$
\text{For w(t) = 1:} \\ 
\frac{\int_{0}^{1} s(t) dt}{\int_{0}^{1} dt} = \frac{a}{2} + b
$$


$$
\text{For w(t) = cx + d:} \\
\frac{\int_{0}^{1} (cx + d)(ax + b) dt}{\int_{0}^{1} (cx + d) dt} = \frac{2ac + 3ad + 3bc + 6bd}{6c + 12d}
$$

$$
\text{For w(t) = 2^x:} \\
\frac{\int_{0}^{1} 2^x (ax + b) dt}{\int_{0}^{1} 2^x dt} = a + b\ln(2)
$$



## constant weight function


```{r}
get_wavg <- function(slp, w) {
    slp_d <- slp %>%
        WEPPR:::remove_slp_transitions() %>%
        mutate(cuml_dist = WEPPR:::calculate_total_distance(.)) %>%
        mutate(norm_cuml_dist = cuml_dist / max(cuml_dist))
    
    numerator <- integrate(function(t) {
        y_t <- approx(slp_d$norm_cuml_dist, slp_d$slope, xout = t)$y
        y_t * w(t)
    }, lower = 0, upper = 1)$value
    
    denominator <- integrate(function(t) {
        w(t)
    }, lower = 0, upper = 1)$value
    
    weighted_slope <- numerator / denominator
    
    return(weighted_slope)
}
```


```{r}
w_const <- function(t) 1
get_wavg(slp, Vectorize(function(t) 1))
```


## linear weight function

```{r}
max_dist <- max(WEPPR:::calculate_total_distance(slp))
get_wavg(slp, function(t) 1 - (t / max_dist))
```

## exponential weight function

```{r}
b <- 1
get_wavg(slp, function(t) b^t)
```

## All 

```{r}
get_all_wavg(slp)
```

# Soil

We apply the same idea on the soil data.

$$
wavg_{i} = \frac{\int_{0}^{1} w_{sol}(t) \cdot w_{dist}(t) \cdot s_i(t) dt}{\int_{0}^{1} w_{sol}(t) \cdot w_{dist}(t) dt}
$$

```{r}
fpath_sol <- system.file("extdata", "071000090603_2.sol", package="WEPPR")
fpath_slp <- system.file("extdata", "071000090603_2.slp", package = "WEPPR")
slp <- read_slp(fpath_slp)
sol <- read_sol(fpath_sol)
slp_sol <- merge_slp_sol(slp, sol)

slp_sol %<>%
    mutate(cum_dist = WEPPR:::calculate_cum_dist(layer, distance)) %>%
    mutate(distance = cum_dist / max(cum_dist)) %>% 
    select(-cum_dist)
```


```{r}
#' Calculate the weighted average of a given property for a specific layer in the soil profile
#'
#' @param group_data A data frame containing the soil data for a specific layer
#' @param w_sol Function representing the weight function for soil thickness
#' @param w_dist Function representing the weight function for distance
#' @param property Name of the property for which the weighted average is calculated
#' @return Weighted average of the given property for the specific layer
calc_wavg_property <- function(group_data, w_sol, w_dist, property) {
    
    # Define the integrand function
    integrand <- function(x) {
        t <- x[1]
        s <- x[2]
        
        # Interpolate the property values at the given thickness
        prop_t_s <- approx(group_data$norm_solthk,
                           group_data[[property]],
                           xout = t,
                           rule = 2)$y
        
        # Calculate the weighted value of the property
        result <- w_sol(t) * w_dist(s) * prop_t_s
        
        return(result)
    }
    
    # Calculate the integral for the numerator
    numerator <-
        cubature::adaptIntegrate(integrand, c(0, 0), c(1, 1))$integral
    
    # Define the integrand function for the denominator
    integrand_denom <- function(x) {
        t <- x[1]
        s <- x[2]
        
        # Calculate the product of the weight functions
        w_sol(t) * w_dist(s)
    }
    
    # Calculate the integral for the denominator
    denominator <-
        cubature::adaptIntegrate(integrand_denom, c(0, 0), c(1, 1))$integral
    
    # Calculate the weighted average for the property
    weighted_avg_property <- numerator / denominator
    
    return(weighted_avg_property)
}

#' Calculate the weighted average of all properties for each layer in the soil profile
#'
#' @param data A data frame containing the soil data
#' @param w_sol Function representing the weight function for soil thickness
#' @param w_dist Function representing the weight function for distance
#' @return A data frame with the weighted averages for each property
get_wavg_sol <- function(data, w_sol, w_dist) {
  
  # Define columns to exclude from the weighted average calculation
  excluded_columns <- c("layer", "slope", "distance", "solthk", "cum_dist")
  
  # Get the properties to calculate the weighted average for
  properties <- setdiff(colnames(data), excluded_columns)
  
  # Normalize solthk and distance to [0,1] range
  data <- data %>%
      group_by(layer) %>%
      mutate(norm_solthk = solthk / max(solthk),
             norm_dist = distance / max(distance))
  
  # Calculate the weighted average for each property for each layer
  results <- data %>%
      group_by(layer) %>%
      summarize(weighted_avgs = list(purrr::imap(
          purrr::set_names(properties),
          ~ calc_wavg_property(.data, w_sol, w_dist, .x)
      )), .groups = 'drop')
  
  print(unlist(results))
  
  # Calculate the overall weighted average for each property
  weighted_avgs <- lapply(properties, function(x) {
      property_avgs <- purrr::map_dbl(results$weighted_avgs, ~ .x[[x]])
      mean(property_avgs, na.rm = TRUE)
  })
  
  names(weighted_avgs) <- properties
  
  return(as.data.frame(weighted_avgs))
}

b <- 10
w_const = function(t) 1
w_linear = function(t) t
w_exp = function(t) b^t
test <- slp_sol[, c("layer", "sand", "orgmat", "solthk", "slope", "distance")]
get_wavg_sol(test, w_linear, w_linear)

rbind(
    get_wavg_sol(slp_sol, w_const, w_const),
    get_wavg_sol(slp_sol, w_linear, w_linear),
    get_wavg_sol(slp_sol, w_exp, w_exp),
    get_wavg_sol(slp_sol, w_const, w_exp)
)
```

```{r}
slp_sol
```


```{r}
rbind(
    WEPPemulator:::get_wavg_sol(slp_sol, w_dist = 1, w_thk = 1),
    WEPPemulator:::get_wavg_sol(slp_sol, w_dist = 2, w_thk = 1),
    WEPPemulator:::get_wavg_sol(slp_sol, w_dist = 1, w_thk = 2)
)
```


```{r}
get_all_wavg_sol(slp, sol)
```
